{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection';\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor';\nimport iteratorSymbol from '@stdlib/symbol-iterator';\nimport MAX_ITERATIONS from '@stdlib/constants-float64-max';\nimport arraylike2object from '@stdlib/array-base-arraylike2object';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Circular buffer constructor.\n*\n* @constructor\n* @param {(PositiveInteger|Collection)} buffer - buffer size or an array-like object to use as the underlying buffer\n* @throws {TypeError} must provide either a valid buffer size or an array-like object\n* @returns {CircularBuffer} circular buffer instance\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Fill the buffer...\n* var v = b.push( 'foo' );\n* // returns undefined\n*\n* v = b.push( 'bar' );\n* // returns undefined\n*\n* v = b.push( 'beep' );\n* // returns undefined\n*\n* // Add another value to the buffer and return the removed element:\n* v = b.push( 'boop' );\n* // returns 'foo'\n*/\nfunction CircularBuffer( buffer ) {\n\tvar buf;\n\tvar i;\n\tif ( !(this instanceof CircularBuffer) ) {\n\t\treturn new CircularBuffer( buffer );\n\t}\n\tif ( isPositiveInteger( buffer ) ) {\n\t\tbuf = [];\n\t\tfor ( i = 0; i < buffer; i++ ) {\n\t\t\tbuf.push( 0.0 ); // initialize with zeros, but could be any value (we're just ensuring a contiguous block of memory)\n\t\t}\n\t} else if ( isCollection( buffer ) ) {\n\t\tbuf = buffer;\n\t} else {\n\t\tthrow new TypeError( format( '1S3An,PK', buffer ) );\n\t}\n\tthis._buffer = arraylike2object( buf );\n\tthis._length = buf.length;\n\tthis._count = 0;\n\tthis._i = -1;\n\treturn this;\n}\n\n/**\n* Clears the buffer.\n*\n* @name clear\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {CircularBuffer} circular buffer instance\n*\n* @example\n* var b = new CircularBuffer( 2 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Get the number of elements currently in the buffer:\n* var n = b.count;\n* // returns 2\n*\n* // Clear the buffer:\n* b.clear();\n*\n* // Get the number of buffer values:\n* n = b.count;\n* // returns 0\n*/\nsetReadOnly( CircularBuffer.prototype, 'clear', function clear() {\n\tthis._count = 0;\n\tthis._i = -1; // this ensures that we always fill the buffer starting at index `0`.\n\treturn this;\n});\n\n/**\n* Number of elements currently in the buffer.\n*\n* @name count\n* @memberof CircularBuffer.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var b = new CircularBuffer( 4 );\n*\n* // Get the value count:\n* var n = b.count;\n* // returns 0\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n*\n* // Get the value count:\n* n = b.count;\n* // returns 2\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'count', function get() {\n\treturn this._count;\n});\n\n/**\n* Boolean indicating whether a circular buffer is full.\n*\n* @name full\n* @memberof CircularBuffer.prototype\n* @readonly\n* @type {boolean}\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Determine if the buffer is full:\n* var bool = b.full;\n* // returns false\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Determine if the buffer is full:\n* bool = b.full;\n* // returns true\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'full', function get() {\n\treturn this._count === this._length;\n});\n\n/**\n* Returns an iterator for iterating over a circular buffer.\n*\n* ## Notes\n*\n* -   An iterator does not iterate over partially full buffers.\n*\n* @name iterator\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @param {NonNegativeInteger} [niters] - number of iterations\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {Iterator} iterator\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Create an iterator:\n* var it = b.iterator( b.length );\n*\n* // Iterate over the buffer...\n* var v = it.next().value;\n* // returns 'bar'\n*\n* v = it.next().value;\n* // returns 'beep'\n*\n* v = it.next().value;\n* // returns 'boop'\n*\n* var bool = it.next().done;\n* // returns true\n*/\nsetReadOnly( CircularBuffer.prototype, 'iterator', function iterator( niters ) {\n\tvar iter;\n\tvar self;\n\tvar FLG;\n\tvar N;\n\tvar n;\n\tvar i;\n\n\tif ( arguments.length ) {\n\t\tif ( !isNonNegativeInteger( niters ) ) {\n\t\t\tthrow new TypeError( format( '1S32K,Ez', niters ) );\n\t\t}\n\t\tN = niters;\n\t} else {\n\t\tN = MAX_ITERATIONS;\n\t}\n\tself = this;\n\n\t// Initialize the iteration index and counter:\n\ti = this._i;\n\tn = 0;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\tif ( iteratorSymbol ) {\n\t\tsetReadOnly( iter, iteratorSymbol, factory );\n\t}\n\treturn iter;\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\t/* eslint-disable no-underscore-dangle */\n\t\tn += 1;\n\t\tif ( FLG || n > N ) {\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\t// If the buffer is only partially full, don't allow iteration over \"undefined\" elements (this ensures similar behavior with `toArray()`)...\n\t\tif ( self._count !== self._length ) {\n\t\t\tFLG = true;\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\ti = (i+1) % self._length;\n\t\treturn {\n\t\t\t'value': self._buffer.accessors[ 0 ]( self._buffer.data, i ),\n\t\t\t'done': false\n\t\t};\n\n\t\t/* eslint-enable no-underscore-dangle */\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = true;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn self.iterator( N );\n\t}\n});\n\n/**\n* Circular buffer length (i.e., capacity).\n*\n* @name length\n* @memberof CircularBuffer.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var b = new CircularBuffer( 4 );\n*\n* // Get the buffer capacity:\n* var len = b.length;\n* // returns 4\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'length', function get() {\n\treturn this._length;\n});\n\n/**\n* Adds a value to the circular buffer.\n*\n* @name push\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @param {*} value - value to add\n* @returns {(*|void)} removed element or undefined\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Fill the buffer:\n* var v = b.push( 'foo' );\n* // returns undefined\n*\n* v = b.push( 'bar' );\n* // returns undefined\n*\n* v = b.push( 'beep' );\n* // returns undefined\n*\n* // Add another value to the buffer and return the removed element:\n* v = b.push( 'boop' );\n* // returns 'foo'\n*/\nsetReadOnly( CircularBuffer.prototype, 'push', function push( value ) {\n\tvar set;\n\tvar get;\n\tvar buf;\n\tvar v;\n\n\tbuf = this._buffer.data;\n\tget = this._buffer.accessors[ 0 ];\n\tset = this._buffer.accessors[ 1 ];\n\n\t// Compute the next buffer index:\n\tthis._i = (this._i+1) % this._length;\n\n\t// Check if we are still filling the buffer...\n\tif ( this._count < this._length ) {\n\t\tset( buf, this._i, value );\n\t\tthis._count += 1;\n\t\treturn;\n\t}\n\t// Replace an existing buffer element...\n\tv = get( buf, this._i );\n\tset( buf, this._i, value );\n\treturn v;\n});\n\n/**\n* Returns an array of circular buffer values.\n*\n* @name toArray\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {Array} circular buffer values\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Get an array of buffer values:\n* var vals = b.toArray();\n* // returns [ 'bar', 'beep', 'boop' ]\n*/\nsetReadOnly( CircularBuffer.prototype, 'toArray', function toArray() {\n\tvar buf;\n\tvar get;\n\tvar out;\n\tvar k;\n\tvar i;\n\n\tbuf = this._buffer.data;\n\tget = this._buffer.accessors[ 0 ];\n\n\tout = [];\n\tfor ( i = 1; i <= this._count; i++ ) {\n\t\t// Note: in a full buffer, `count == length`; in a partially full buffer, we need to ensure we always start at index `0`\n\t\tk = (this._i+i) % this._count;\n\t\tout.push( get( buf, k ) );\n\t}\n\treturn out;\n});\n\n/**\n* Serializes a circular buffer as JSON.\n*\n* ## Notes\n*\n* -   `JSON.stringify()` implicitly calls this method when stringifying a `CircularBuffer` instance.\n*\n* @name toJSON\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {Object} serialized circular buffer\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Serialize to JSON:\n* var o = b.toJSON();\n* // returns { 'type': 'circular-buffer', 'length': 3, 'data': [ 'bar', 'beep', 'boop' ] }\n*/\nsetReadOnly( CircularBuffer.prototype, 'toJSON', function toJSON() {\n\tvar out = {};\n\tout.type = 'circular-buffer';\n\tout.length = this._length;\n\tout.data = this.toArray();\n\treturn out;\n});\n\n\n// EXPORTS //\n\nexport default CircularBuffer;\n"],"names":["CircularBuffer","buffer","buf","i","this","isPositiveInteger","push","isCollection","TypeError","format","_buffer","arraylike2object","_length","length","_count","_i","setReadOnly","prototype","setReadOnlyAccessor","niters","iter","self","FLG","N","n","arguments","isNonNegativeInteger","MAX_ITERATIONS","next","end","iteratorSymbol","factory","done","value","accessors","data","iterator","set","get","v","out","k","toArray"],"mappings":"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"}